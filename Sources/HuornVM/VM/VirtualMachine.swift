// HuornVM - Virtual Machine

import Foundation
import Virtualization

/// A virtual machine instance
@MainActor
public class VirtualMachine: ObservableObject {
    /// The bundle URL containing VM files
    public let bundleURL: URL

    /// VM configuration
    public let configuration: VMConfiguration

    /// Current VM state
    @Published public var state: VMState = .stopped

    /// VM IP address (available when running)
    @Published public private(set) var ipAddress: String?

    /// MAC address for network interface
    public private(set) var macAddress: String?

    /// The underlying VZVirtualMachine
    internal var vzMachine: VZVirtualMachine?

    /// Delegate for VM events
    private var delegate: VMDelegate?

    init(bundleURL: URL, configuration: VMConfiguration, vzMachine: VZVirtualMachine? = nil) {
        self.bundleURL = bundleURL
        self.configuration = configuration
        self.vzMachine = vzMachine
    }

    /// Start the virtual machine
    public func start() async throws {
        guard state == .stopped || state == .created else {
            throw VMError.startFailed("VM is not in a startable state")
        }

        state = .starting

        do {
            if vzMachine == nil {
                vzMachine = try await createVZMachine()
            }

            guard let vm = vzMachine else {
                throw VMError.startFailed("Failed to create virtual machine")
            }

            // Set up delegate
            let delegate = VMDelegate(vm: self)
            vm.delegate = delegate
            self.delegate = delegate

            // MAC address is generated by Virtualization framework when using NAT
            // We'll discover it via ARP lookup later

            try await vm.start()
            state = .running

            // Start IP discovery
            Task {
                await discoverIPAddress()
            }
        } catch {
            state = .error
            throw VMError.startFailed(error.localizedDescription)
        }
    }

    /// Stop the virtual machine
    public func stop(force: Bool = false) async throws {
        guard state == .running || state == .paused else {
            throw VMError.stopFailed("VM is not running")
        }

        guard let vm = vzMachine else {
            state = .stopped
            return
        }

        state = .stopping

        do {
            if force || !vm.canRequestStop {
                try await vm.stop()
            } else {
                try vm.requestStop()
                // Wait for graceful shutdown
                let timeout: TimeInterval = 30
                let startTime = Date()
                while vm.state == .running {
                    if Date().timeIntervalSince(startTime) > timeout {
                        try await vm.stop()
                        break
                    }
                    try await Task.sleep(nanoseconds: 500_000_000)
                }
            }
            state = .stopped
            ipAddress = nil
        } catch {
            state = .error
            throw VMError.stopFailed(error.localizedDescription)
        }
    }

    /// Pause the virtual machine
    public func pause() async throws {
        guard state == .running else {
            throw VMError.pauseFailed("VM is not running")
        }

        guard let vm = vzMachine, vm.canPause else {
            throw VMError.pauseFailed("VM cannot be paused")
        }

        state = .pausing

        do {
            try await vm.pause()
            state = .paused
        } catch {
            state = .error
            throw VMError.pauseFailed(error.localizedDescription)
        }
    }

    /// Resume the virtual machine
    public func resume() async throws {
        guard state == .paused else {
            throw VMError.resumeFailed("VM is not paused")
        }

        guard let vm = vzMachine, vm.canResume else {
            throw VMError.resumeFailed("VM cannot be resumed")
        }

        do {
            try await vm.resume()
            state = .running
        } catch {
            state = .error
            throw VMError.resumeFailed(error.localizedDescription)
        }
    }

    /// Wait for SSH to become available
    public func waitForSSH(timeout: TimeInterval = 120) async throws -> SSHConnection {
        let startTime = Date()

        while Date().timeIntervalSince(startTime) < timeout {
            // Wait for IP address
            if ipAddress == nil {
                try await Task.sleep(nanoseconds: 2_000_000_000)
                continue
            }

            // Try to connect
            if let ip = ipAddress {
                do {
                    let connection = try await SSHConnection.connect(to: ip, port: 22)
                    return connection
                } catch {
                    // Connection failed, retry
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                }
            }
        }

        throw VMError.sshTimeout
    }

    /// Get the VZVirtualMachine view for displaying VM GUI
    @available(macOS 15.0, *)
    public var virtualMachineView: VZVirtualMachineView? {
        guard let vm = vzMachine else { return nil }
        let view = VZVirtualMachineView()
        view.virtualMachine = vm
        view.capturesSystemKeys = true
        return view
    }

    // MARK: - Private

    @available(macOS 15.0, *)
    private func createVZMachine() async throws -> VZVirtualMachine {
        let vzConfig = VZVirtualMachineConfiguration()
        vzConfig.cpuCount = configuration.cpuCores
        vzConfig.memorySize = configuration.memoryBytes

        // Load platform configuration
        let hardwareModelPath = bundleURL.appendingPathComponent("hardware_model.bin")
        let machineIdPath = bundleURL.appendingPathComponent("machine_id.bin")
        let auxiliaryPath = bundleURL.appendingPathComponent("auxiliary.img")
        let diskPath = bundleURL.appendingPathComponent("disk.img")

        guard FileManager.default.fileExists(atPath: hardwareModelPath.path) else {
            throw VMError.bundleInvalid("Missing hardware_model.bin")
        }

        let hardwareModelData = try Data(contentsOf: hardwareModelPath)
        guard let hardwareModel = VZMacHardwareModel(dataRepresentation: hardwareModelData) else {
            throw VMError.bundleInvalid("Invalid hardware model")
        }

        let machineIdData = try Data(contentsOf: machineIdPath)
        guard let machineIdentifier = VZMacMachineIdentifier(dataRepresentation: machineIdData) else {
            throw VMError.bundleInvalid("Invalid machine identifier")
        }

        let platform = VZMacPlatformConfiguration()
        platform.hardwareModel = hardwareModel
        platform.machineIdentifier = machineIdentifier
        platform.auxiliaryStorage = try VZMacAuxiliaryStorage(contentsOf: auxiliaryPath)
        vzConfig.platform = platform

        // Boot loader
        vzConfig.bootLoader = VZMacOSBootLoader()

        // Storage
        let diskAttachment = try VZDiskImageStorageDeviceAttachment(url: diskPath, readOnly: false)
        vzConfig.storageDevices = [VZVirtioBlockDeviceConfiguration(attachment: diskAttachment)]

        // Network
        let networkDevice = VZVirtioNetworkDeviceConfiguration()
        networkDevice.attachment = VZNATNetworkDeviceAttachment()
        vzConfig.networkDevices = [networkDevice]

        // Graphics
        let graphics = VZMacGraphicsDeviceConfiguration()
        graphics.displays = [
            VZMacGraphicsDisplayConfiguration(
                widthInPixels: configuration.displayWidth,
                heightInPixels: configuration.displayHeight,
                pixelsPerInch: configuration.displayPPI
            )
        ]
        vzConfig.graphicsDevices = [graphics]

        // Input devices
        vzConfig.keyboards = [VZUSBKeyboardConfiguration()]
        vzConfig.pointingDevices = [VZUSBScreenCoordinatePointingDeviceConfiguration()]

        // Audio
        let audioDevice = VZVirtioSoundDeviceConfiguration()
        let outputStream = VZVirtioSoundDeviceOutputStreamConfiguration()
        outputStream.sink = VZHostAudioOutputStreamSink()
        audioDevice.streams = [outputStream]
        vzConfig.audioDevices = [audioDevice]

        // Shared folders
        if !configuration.sharedFolders.isEmpty {
            var directories: [String: VZSharedDirectory] = [:]
            for folder in configuration.sharedFolders {
                directories[folder.guestTag] = VZSharedDirectory(url: folder.hostPath, readOnly: folder.readOnly)
            }
            let share = VZMultipleDirectoryShare(directories: directories)
            let sharingDevice = VZVirtioFileSystemDeviceConfiguration(tag: VZVirtioFileSystemDeviceConfiguration.macOSGuestAutomountTag)
            sharingDevice.share = share
            vzConfig.directorySharingDevices = [sharingDevice]
        }

        try vzConfig.validate()
        return VZVirtualMachine(configuration: vzConfig)
    }

    private func discoverIPAddress() async {
        // Try to discover IP via DHCP lease file lookup or mDNS
        // For now, poll ARP table for the MAC address
        guard let mac = macAddress else { return }

        for _ in 0..<60 { // Try for 2 minutes
            if let ip = await lookupIPFromMAC(mac) {
                await MainActor.run {
                    self.ipAddress = ip
                }
                return
            }
            try? await Task.sleep(nanoseconds: 2_000_000_000)
        }
    }

    private func lookupIPFromMAC(_ mac: String) async -> String? {
        // Parse ARP table to find IP for MAC address
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/sbin/arp")
        process.arguments = ["-a"]

        let pipe = Pipe()
        process.standardOutput = pipe

        do {
            try process.run()
            process.waitUntilExit()

            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            guard let output = String(data: data, encoding: .utf8) else { return nil }

            // Parse ARP output: "? (192.168.x.x) at aa:bb:cc:dd:ee:ff on en0"
            let normalizedMAC = mac.lowercased()
            for line in output.components(separatedBy: "\n") {
                if line.lowercased().contains(normalizedMAC) {
                    // Extract IP from parentheses
                    if let start = line.firstIndex(of: "("),
                       let end = line.firstIndex(of: ")") {
                        let ip = String(line[line.index(after: start)..<end])
                        return ip
                    }
                }
            }
        } catch {
            return nil
        }

        return nil
    }
}

// MARK: - VM Delegate

private final class VMDelegate: NSObject, VZVirtualMachineDelegate, @unchecked Sendable {
    weak var vm: VirtualMachine?

    init(vm: VirtualMachine) {
        self.vm = vm
        super.init()
    }

    nonisolated func guestDidStop(_ virtualMachine: VZVirtualMachine) {
        Task { @MainActor [weak self] in
            self?.vm?.state = .stopped
        }
    }

    nonisolated func virtualMachine(_ virtualMachine: VZVirtualMachine, didStopWithError error: Error) {
        Task { @MainActor [weak self] in
            self?.vm?.state = .error
        }
    }
}
